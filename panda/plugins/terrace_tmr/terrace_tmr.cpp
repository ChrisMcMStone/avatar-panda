#include "qemu/osdep.h"
#include <stdio.h>
#include <errno.h>
#include <string.h>

#include "panda/plugin.h"



#include "qapi/error.h"
#include "qapi/qmp/qobject.h"
#include "qapi/qmp/qint.h"
#include "qapi/qmp/qdict.h"

#include <iostream>
#include <fstream>
#include <map>
#include <vector>
#include <algorithm>

extern "C" {
#include "qapi/qmp/qjson.h"

    bool init_plugin(void *);
    void uninit_plugin(void *);
}

extern int errno;

/*  We need to store every byte for special memory, which can also be symbolic.
 *  We will use an extra flag field to encode it's type.
 *  This way, the file containing special memory accesses can be edited
 *  afterwards without running PANDA again.
 */
#define IS_SPECIAL 0x01
#define IS_SYMBOLIC 0x02
#define IS_ROM 0x04


namespace {

struct mem_range_t {
    mem_range_t(target_ulong a, uint32_t s, uint8_t f): addr(a), size(s), flags(f){}
    target_ulong addr;
    uint32_t size;
    uint8_t flags;
};

const char * nmem_file_name;
const char * smem_file_name;

std::map<target_ulong,uint8_t> readmap;
std::map<target_ulong, std::vector<std::tuple<uint8_t, uint8_t>>> special_read_map;
std::vector<mem_range_t> memory_ranges;

}


void write_memory_entry(std::ofstream& file, target_ulong addr,
        std::vector<uint8_t> mem)
{
    uint32_t size;
    size = (uint32_t)   mem.size() ;

    file.write( (const char *) &addr, sizeof(target_ulong));
    file.write( (const char *) &size, 4 );
    file.write( (const char *) mem.data(), mem.size());
}


/* The data format written to file is address | length | content */
void write_serialized_memory_map(void)
{
    std::vector<uint8_t> mem;
    target_ulong marker = 0;

    std::ofstream file;
        
    file.open(nmem_file_name, std::ios::out | std::ios::binary);
    
    if (!file) {
        std::cerr << "Failed to open " << nmem_file_name << ":" << strerror(errno) << std::endl;
        exit(1);
    }

    for (auto const& e : readmap) {
        if (mem.empty()){ // Deal with first iteration
            mem.push_back(e.second);
            marker = e.first;
            continue;
        }
        if (e.first == marker + mem.size() ){
            mem.push_back(e.second);
        }
        else {
            write_memory_entry( file, marker, mem);
            mem.clear();
            marker = e.first;
            mem.push_back(e.second);
        }
    }
    write_memory_entry( file, marker, mem );
}

/*
 * The format for the special map is a bit more complex. In essence, it's:
 * address | n_elements | elem_0 | elem_1 | ... | elem_n
 * whereas an element is in the form of
 * value | flags
 */
void write_serialized_special_memory_map(void)
{

    std::ofstream file;
    file.open(smem_file_name, std::ios::out | std::ios::binary);

    if (!file) {
        std::cerr << "Failed to open " << smem_file_name << ":" << strerror(errno) << std::endl;
        exit(1);
    }

    for (auto const& e :  special_read_map) {
        assert(!e.second.empty());
        target_ulong addr = e.first;
        uint32_t size = (uint32_t) e.second.size() ;

        file.write( (const char *) &addr, sizeof(target_ulong));
        file.write( (const char *) &size, 4);
        for (auto const &elem : e.second) {
            uint8_t val, flags;

            std::tie (val, flags) = elem;
            file.write( (const char*) &val, 1);
            file.write( (const char*) &flags, 1);
        }
    }
}

/*
 * This callback splits the memory accesses to byte-sized chunks and logs them,
 * depending on the flags for the cell in the memory_ranges vector.
 * Note that this implementation does not log at all if the access is not within
 * a defined memory_range.
 */
int mem_read_cb(CPUState *cpu, target_ulong pc, target_ulong addr, target_ulong size, void *buf)
{

    for (int i=0; i<size; i++) {
        uint8_t val = ((uint8_t *) buf)[i];
        target_ulong address = addr + i;

        // We need to resolve everytime for accesses accross boundaries
        auto mem_range = std::find_if(memory_ranges.begin(), memory_ranges.end(),
                [address](mem_range_t m) {return ((m.addr <= address) && (address <= m.addr + m.size));});
        // Validate that we want to log this access
        if (mem_range == memory_ranges.end() || mem_range->flags & IS_ROM) continue; 

        // Log special accesses to our special map
        if ( (mem_range->flags & IS_SPECIAL) || (mem_range->flags & IS_SYMBOLIC)) {
            special_read_map[address].emplace_back( val, mem_range->flags);
        } else { // Log normal accesses
            if (readmap.count(address)) continue; //did we already log this?
            readmap[address] = val;
        }
    }
    return 0;
}


#define QDICT_ASSERT_KEY_TYPE(_dict, _key, _type) \
    g_assert(qdict_haskey(_dict, _key) && qobject_type(qdict_get(_dict, _key)) == _type)

// Parses the configuration file generated by avatar
void load_configuration(const char *config_file_name)
{
    QObject *obj;
    QDict *mapping, *conf;
    QList *memories;
    QListEntry *entry;
    target_ulong address;
    uint32_t size;
    uint8_t flags = 0;

    std::ifstream ifs(config_file_name);
    std::string conf_json ((std::istreambuf_iterator<char>(ifs)),
            (std::istreambuf_iterator<char>()));
   
    obj = qobject_from_json(conf_json.c_str());

    if (!obj || qobject_type(obj) != QTYPE_QDICT) {
        fprintf(stderr, "Error parsing JSON configuration file\n");
        exit(1);
    }

    conf = qobject_to_qdict(obj);

    memories = qobject_to_qlist(qdict_get(conf, "memory_mapping"));
    g_assert(memories);

    QLIST_FOREACH_ENTRY(memories, entry)
    {
        mapping = qobject_to_qdict(entry->value);
        QDICT_ASSERT_KEY_TYPE(mapping, "size", QTYPE_QINT);
        QDICT_ASSERT_KEY_TYPE(mapping, "address", QTYPE_QINT);

        size = qdict_get_int(mapping, "size");
        address = qdict_get_int(mapping, "address");

        if (qdict_haskey(mapping, "is_rom") && qdict_get_bool(mapping, "is_rom"))
            flags |= IS_ROM;

        if (qdict_haskey(mapping, "is_symbolic") && qdict_get_bool(mapping, "is_symbolic"))
            flags |= IS_SYMBOLIC;

        if (qdict_haskey(mapping, "is_special") && qdict_get_bool(mapping, "is_special"))
            flags |= IS_SPECIAL;

        memory_ranges.emplace_back( address, size, flags );
        printf("Adding range with flags: %x\n", flags);

    }

}


bool init_plugin(void *self)
{

    panda_arg_list *args = panda_get_args("terrace_tmr");

    nmem_file_name = panda_parse_string_opt(args, "memory_file",
            "dumped_mem.bin", "File to store memory reads for initialization");
    smem_file_name = panda_parse_string_opt(args, "special_memory_file",
            "special_reads.bin", "File storing special memory read");
    const char *config_file_name = panda_parse_string_opt(args, "config_file",
            "conf.json", "JSON file configuring the memory ranges");


    load_configuration(config_file_name);



    panda_enable_memcb();

    panda_cb pcb;

    // Assumption: in monolithic memory spaces, virt_mem == phys_mem.
    pcb.virt_mem_after_read = mem_read_cb;
    panda_register_callback(self, PANDA_CB_VIRT_MEM_AFTER_READ, pcb);

    return true;
}

void uninit_plugin(void *self) {
    write_serialized_memory_map();
    write_serialized_special_memory_map();
}
