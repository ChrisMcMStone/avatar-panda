#include "qemu/osdep.h"
#include <stdio.h>
#include <errno.h>
#include <string.h>

#include "panda/plugin.h"



#include "qapi/error.h"
#include "qapi/qmp/qobject.h"
#include "qapi/qmp/qint.h"
#include "qapi/qmp/qdict.h"

#include <iostream>
#include <fstream>
#include <map>
#include <vector>

extern "C" {
#include "qapi/qmp/qjson.h"

    bool init_plugin(void *);
    void uninit_plugin(void *);
}

extern int errno;

/*  We need to store every byte for special memory, which can also be symbolic.
 *  We will use an extra flag field to encode it's type.
 *  This way, the file containing special memory accesses can be edited
 *  afterwards without running PANDA again.
 */
#define IS_SPECIAL 0x01
#define IS_SYMBOLIC 0x02
#define IS_ROM 0x04

typedef struct mem_range {
    target_ulong addr;
    uint32_t size;
    uint8_t flags;
} mem_range_t;

std::ofstream mem_dump_file;
std::ofstream smem_trace_file;
std::map<target_ulong,uint8_t> readmap;
std::map<target_ulong, std::vector<std::tuple<uint8_t, uint8_t>>> special_read_map;
std::vector<mem_range_t> memory_ranges;

/* The data format written to file is address | length | content */
void write_serialized_memory_map(void)
{
    std::vector<uint8_t> mem;
    target_ulong addr, marker = 0;
    uint32_t size;

    for (auto const& e : readmap) {
        if (e.first == marker+1){
        }
        else if (!mem.empty()){ // mem.empty() only happens on first iter
            addr = marker - mem.size() + 1;
            size = (uint32_t)   mem.size() ;

            mem_dump_file.write( (const char *) &addr, sizeof(target_ulong));
            mem_dump_file.write( (const char *) &size, 4 );
            for (auto const &b : mem) {
                mem_dump_file.write( (const char*) &b, 1);
            }
            mem.clear();
        }

        mem.push_back(e.second);
        marker = e.first;
    }
}

/*
 * The format for the special map is a bit more complex. In essence, it's:
 * address | n_elements | elem_0 | elem_1 | ... | elem_n
 * whereas an element is in the form of
 * value | flags
 */
void write_serialized_special_memory_map(void)
{
    uint8_t val, flags;
    uint32_t size;
    target_ulong addr = 0;

    for (auto const& e :  special_read_map) {
        assert(!e.second.empty());
        addr = e.first;
        size = (uint32_t) e.second.size() ;

        smem_trace_file.write( (const char *) &addr, sizeof(target_ulong));
        smem_trace_file.write( (const char *) &size, 4);
        for (auto const &elem : e.second) {
            std::tie (val, flags) = elem;
            smem_trace_file.write( (const char*) &val, 1);
            smem_trace_file.write( (const char*) &flags, 1);
        }
    }
}

/*
 * This callback splits the memory accesses to byte-sized chunks and logs them,
 * depending on the flags for the cell in the memory_ranges vector.
 * Note that this implementation does not log at all if the access is not within
 * a defined memory_range.
 */
int mem_read_cb(CPUState *cpu, target_ulong pc, target_ulong addr, target_ulong size, void *buf)
{
    uint8_t val;
    mem_range_t mem_range;

    for (int i=0; i<size; i++) {
        val = ((uint8_t *) buf)[i];
        mem_range = {0, 0, 0};

        // We need to resolve everytime for accesses accross boundaries
        for (auto const &m : memory_ranges) {
            if ( (m.addr <= addr + i) && (addr + i <= m.addr + m.size)) {
                mem_range = m;
                break;
            }
        }

        // Validate that we want to log this access
        if (mem_range.size == 0 || mem_range.flags & IS_ROM) continue; 

        // Log special accesses to our special map
        if ( (mem_range.flags & IS_SPECIAL) || (mem_range.flags & IS_SYMBOLIC)) {
            special_read_map[pc+i].push_back( std::make_tuple(val, mem_range.flags));
        } else { // Log normal accesses
            if (readmap.count(pc+i)) continue; //did we already log this?
            readmap[pc+i] = val;
        }
    }
    return 0;
}


#define QDICT_ASSERT_KEY_TYPE(_dict, _key, _type) \
    g_assert(qdict_haskey(_dict, _key) && qobject_type(qdict_get(_dict, _key)) == _type)

// Parses the configuration file generated by avatar
void load_configuration(const char *config_file_name)
{
    QObject *obj;
    QDict *mapping, *conf;
    QList *memories;
    QListEntry *entry;
    target_ulong address;
    uint32_t size;
    uint8_t flags = 0;

    std::ifstream ifs(config_file_name);
    std::string conf_json ((std::istreambuf_iterator<char>(ifs)),
            (std::istreambuf_iterator<char>()));
   
    obj = qobject_from_json(conf_json.c_str());

    if (!obj || qobject_type(obj) != QTYPE_QDICT) {
        fprintf(stderr, "Error parsing JSON configuration file\n");
        exit(1);
    }

    conf = qobject_to_qdict(obj);

    memories = qobject_to_qlist(qdict_get(conf, "memory_mapping"));
    g_assert(memories);

    QLIST_FOREACH_ENTRY(memories, entry)
    {
        mapping = qobject_to_qdict(entry->value);
        QDICT_ASSERT_KEY_TYPE(mapping, "size", QTYPE_QINT);
        QDICT_ASSERT_KEY_TYPE(mapping, "address", QTYPE_QINT);

        size = qdict_get_int(mapping, "size");
        address = qdict_get_int(mapping, "address");

        if (qdict_haskey(mapping, "is_rom") && qdict_get_bool(mapping, "is_rom"))
            flags |= IS_ROM;

        if (qdict_haskey(mapping, "is_symbolic") && qdict_get_bool(mapping, "is_symbolic"))
            flags |= IS_SYMBOLIC;

        if (qdict_haskey(mapping, "is_special") && qdict_get_bool(mapping, "is_special"))
            flags |= IS_SPECIAL;

        memory_ranges.push_back( (mem_range_t) { address, size, flags} );

    }

}


bool init_plugin(void *self)
{

    panda_arg_list *args = panda_get_args("terrace_tmr");

    const char *nmem_file_name = panda_parse_string_opt(args, "memory_file",
            "dumped_mem.bin", "File to store memory reads for initialization");
    const char *smem_file_name = panda_parse_string_opt(args, "special_memory_file",
            "special_reads.bin", "File storing special memory read");
    const char *config_file_name = panda_parse_string_opt(args, "config_file",
            "conf.json", "JSON file configuring the memory ranges");

    smem_trace_file.open(smem_file_name, std::ios::out | std::ios::binary);
    mem_dump_file.open(nmem_file_name, std::ios::out | std::ios::binary);
 

    load_configuration(config_file_name);



    panda_enable_memcb();

    panda_cb pcb;

    // Assumption: in monolithic memory spaces, virt_mem == phys_mem.
    pcb.virt_mem_after_read = mem_read_cb;
    panda_register_callback(self, PANDA_CB_VIRT_MEM_AFTER_READ, pcb);

    return true;
}

void uninit_plugin(void *self) {
    write_serialized_memory_map();
    write_serialized_special_memory_map();
    mem_dump_file.close();
    smem_trace_file.close();
}
